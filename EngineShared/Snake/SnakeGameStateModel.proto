// Regenerate swift file
// PROMPT> protoc --swift_out=. SnakeGameStateModel.proto
syntax = "proto3";

message SnakeGameStateModelPosition {
	// The coordinate system origin is in the left/bottom corner.
	uint32 x = 1;
	uint32 y = 2;
}

message SnakeGameStateModelPlayer {
    // Is the snake alive/dead.
    bool alive = 1;

    // The array start is the snake head. The array tail is the snake tail.
	repeated SnakeGameStateModelPosition body_positions = 2;
}

message SnakeGameStateModelLevel {
    // Reference to the level file, stored in CSV file format.
    // PROBLEM: The level file can be renamed, so it's fragile to refer to its filename.
    // SOLUTION: Use a version4 UUID, so it's possible finding the original level file.
    string uuid = 1;

	// The level has a size: width * height.
	uint32 width = 2;
	uint32 height = 3;

	// Places where the snake can go.
	repeated SnakeGameStateModelPosition empty_positions = 4;
}

// Full snapshot of the grid in a single time step.
// This snapshot can easily be check for collisions/cheating.
message SnakeGameStateIngameModel {
	SnakeGameStateModelLevel level = 1;

	// There may be food or there may be no food.
	oneof optional_food_position {
		SnakeGameStateModelPosition food_position = 2;
	}

	// While ingame it's uncertain which of the players becomes the winner or the looser.
	oneof optional_player_a {
		SnakeGameStateModelPlayer player_a = 3;
	}
	oneof optional_player_b {
		SnakeGameStateModelPlayer player_b = 4;
	}
}

message SnakeGameStateWinnerLooserModelStep {
	// There may be food or there may be no food.
	oneof optional_food_position {
		SnakeGameStateModelPosition food_position = 1;
	}

	// There is always the player A (the winner).
	SnakeGameStateModelPlayer player_a = 2;

	// There may be an opponent player B (the looser).
	oneof optional_player_b {
		SnakeGameStateModelPlayer player_b = 3;
	}
}

message SnakeGameStateWinnerLooserModel {
	SnakeGameStateModelLevel level = 1;

	repeated SnakeGameStateWinnerLooserModelStep steps = 2;
}
