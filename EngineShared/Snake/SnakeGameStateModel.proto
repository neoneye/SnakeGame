// Regenerate swift file
// PROMPT> protoc --swift_out=. SnakeGameStateModel.proto
syntax = "proto3";

message SnakeGameStateModelPosition {
	// The coordinate system origin is in the left/bottom corner.
	uint32 x = 1;
	uint32 y = 2;
}

message SnakeGameStateModelPlayer {
    // Is the snake alive/dead.
    bool alive = 1;

    // The array start is the snake head. The array tail is the snake tail.
    // Two adjacent positions have a distance of exactly 1 unit.
    // The positions does not overlap with the level walls.
    // The positions does not overlap the player itself (no duplicate positions).
    // The positions does not overlap with an opponent player.
	repeated SnakeGameStateModelPosition body_positions = 2;
}

message SnakeGameStateModelLevel {
    // Reference to the level file, stored in CSV file format.
    // PROBLEM: The level file can be renamed, so it's fragile to refer to its filename.
    // SOLUTION: Use a version4 UUID, so it's possible finding the original level file.
    string uuid = 1;

	// The level has a size: width * height.
	uint32 width = 2;
	uint32 height = 3;

	// Places where the snake can go.
	repeated SnakeGameStateModelPosition empty_positions = 4;
}

// Full snapshot of the grid for a single time step.
//
// Benefit of a full snapshot. It can easily be checked for collisions/cheating.
//
// Benefit of a full snapshot. Jump directly to a particular timestep.
// No need to replay 345 time steps, to recreate a particular moment in a game.
//
// Drawback of a full snapshot: Lots of data stored.
message SnakeGameStateIngameModel {
	SnakeGameStateModelLevel level = 1;
    SnakeGameStateStepModel step = 2;
}

message SnakeGameStateStepModel {
	// There may be food or there may be no food.
	oneof optional_food_position {
		SnakeGameStateModelPosition food_position = 1;
	}

	// While ingame it's uncertain which of the players becomes the winner or the looser.
    // This is determined after the game have ended.
    //
    // When one of the player dies, then assign "alive=false".
    // The player is never set to "nil".
    //
    // In a two player game, there are both player_a and player_b.
    // Both players are "non-nil" througout the entire game.
    //
    // In a single player game, there is either player_a or player_b.
    // The opponent player is "nil" thoughout the entire game.
	oneof optional_player_a {
		SnakeGameStateModelPlayer player_a = 2;
	}
	oneof optional_player_b {
		SnakeGameStateModelPlayer player_b = 3;
	}
}

message SnakeGameStateWinnerLooserModelStep {
	// There may be food or there may be no food.
	oneof optional_food_position {
		SnakeGameStateModelPosition food_position = 1;
	}

	// There is always the player A (the winner).
	SnakeGameStateModelPlayer player_a = 2;

	// There may be an opponent player B (the looser).
	oneof optional_player_b {
		SnakeGameStateModelPlayer player_b = 3;
	}
}

message SnakeGameStateWinnerLooserModel {
	SnakeGameStateModelLevel level = 1;

	repeated SnakeGameStateWinnerLooserModelStep steps = 2;
}
