// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SnakeDataset.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Regenerate swift file
/// PROMPT> protoc --swift_out=. SnakeDataset.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SnakeDatasetCauseOfDeath: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The player have died from one or more unspecified reasons.
  case other // = 0

  /// The player attempted to move into a wall, which is deadly.
  case collisionWithWall // = 1

  /// The player attempted to move into itself. Eating snake is deadly.
  case collisionWithItself // = 2

  /// The player attempted to move into the opponent player. Eating another snake is also deadly.
  case collisionWithOpponent // = 3

  /// The AI continued doing the same moves over and over, which is deadly.
  case stuckInLoop // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .other
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .other
    case 1: self = .collisionWithWall
    case 2: self = .collisionWithItself
    case 3: self = .collisionWithOpponent
    case 4: self = .stuckInLoop
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .other: return 0
    case .collisionWithWall: return 1
    case .collisionWithItself: return 2
    case .collisionWithOpponent: return 3
    case .stuckInLoop: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SnakeDatasetCauseOfDeath: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [SnakeDatasetCauseOfDeath] = [
    .other,
    .collisionWithWall,
    .collisionWithItself,
    .collisionWithOpponent,
    .stuckInLoop,
  ]
}

#endif  // swift(>=4.2)

struct SnakeDatasetPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The coordinate system origin is in the left/bottom corner.
  var x: UInt32 = 0

  var y: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SnakeDatasetPlayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is the snake alive/dead.
  var alive: Bool = false

  /// The array start is the snake head. The array tail is the snake tail.
  /// Two adjacent positions have a distance of exactly 1 unit.
  /// The positions does not overlap with the level walls.
  /// The positions does not overlap the player itself (no duplicate positions).
  /// The positions does not overlap with an opponent player.
  var bodyPositions: [SnakeDatasetPosition] = []

  /// Reference to what player it is. Is it human or bot.
  /// If it's a bot, then what particular bot is it.
  /// PROBLEM: The bot can be renamed, so it's fragile refering to its bot-name.
  /// SOLUTION: Use a version4 UUID, so it's possible finding the original bot implementation.
  var uuid: String = String()

  /// Conditions resulting in a player's death.
  var causeOfDeath: SnakeDatasetCauseOfDeath = .other

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SnakeDatasetLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to the level file, stored in CSV file format.
  /// PROBLEM: The level file can be renamed, so it's fragile to refer to its filename.
  /// SOLUTION: Use a version4 UUID, so it's possible finding the original level file.
  var uuid: String = String()

  /// The level has a size: width * height.
  var width: UInt32 = 0

  var height: UInt32 = 0

  /// Places where the snake can go.
  var emptyPositions: [SnakeDatasetPosition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Full snapshot of the grid for a single time step.
///
/// Benefit of a full snapshot. It can easily be checked for collisions/cheating.
///
/// Benefit of a full snapshot. Jump directly to a particular timestep.
/// No need to replay 345 time steps, to recreate a particular moment in a game.
///
/// Drawback of a full snapshot: Lots of data stored.
struct SnakeDatasetIngame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var level: SnakeDatasetLevel {
    get {return _storage._level ?? SnakeDatasetLevel()}
    set {_uniqueStorage()._level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return _storage._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {_uniqueStorage()._level = nil}

  var step: SnakeDatasetStep {
    get {return _storage._step ?? SnakeDatasetStep()}
    set {_uniqueStorage()._step = newValue}
  }
  /// Returns true if `step` has been explicitly set.
  var hasStep: Bool {return _storage._step != nil}
  /// Clears the value of `step`. Subsequent reads from it will return its default value.
  mutating func clearStep() {_uniqueStorage()._step = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SnakeDatasetStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// There may be food or there may be no food.
  var optionalFoodPosition: OneOf_OptionalFoodPosition? {
    get {return _storage._optionalFoodPosition}
    set {_uniqueStorage()._optionalFoodPosition = newValue}
  }

  var foodPosition: SnakeDatasetPosition {
    get {
      if case .foodPosition(let v)? = _storage._optionalFoodPosition {return v}
      return SnakeDatasetPosition()
    }
    set {_uniqueStorage()._optionalFoodPosition = .foodPosition(newValue)}
  }

  /// While ingame it's uncertain which of the players becomes the winner or the looser.
  /// This is determined after the game have ended.
  ///
  /// When one of the player dies, then assign "alive=false".
  /// The player is never set to "nil".
  ///
  /// In a two player game, there are both player_a and player_b.
  /// Both players are "non-nil" througout the entire game.
  ///
  /// In a single player game, there is either player_a or player_b.
  /// The opponent player is "nil" thoughout the entire game.
  var optionalPlayerA: OneOf_OptionalPlayerA? {
    get {return _storage._optionalPlayerA}
    set {_uniqueStorage()._optionalPlayerA = newValue}
  }

  var playerA: SnakeDatasetPlayer {
    get {
      if case .playerA(let v)? = _storage._optionalPlayerA {return v}
      return SnakeDatasetPlayer()
    }
    set {_uniqueStorage()._optionalPlayerA = .playerA(newValue)}
  }

  var optionalPlayerB: OneOf_OptionalPlayerB? {
    get {return _storage._optionalPlayerB}
    set {_uniqueStorage()._optionalPlayerB = newValue}
  }

  var playerB: SnakeDatasetPlayer {
    get {
      if case .playerB(let v)? = _storage._optionalPlayerB {return v}
      return SnakeDatasetPlayer()
    }
    set {_uniqueStorage()._optionalPlayerB = .playerB(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// There may be food or there may be no food.
  enum OneOf_OptionalFoodPosition: Equatable {
    case foodPosition(SnakeDatasetPosition)

  #if !swift(>=4.1)
    static func ==(lhs: SnakeDatasetStep.OneOf_OptionalFoodPosition, rhs: SnakeDatasetStep.OneOf_OptionalFoodPosition) -> Bool {
      switch (lhs, rhs) {
      case (.foodPosition(let l), .foodPosition(let r)): return l == r
      }
    }
  #endif
  }

  /// While ingame it's uncertain which of the players becomes the winner or the looser.
  /// This is determined after the game have ended.
  ///
  /// When one of the player dies, then assign "alive=false".
  /// The player is never set to "nil".
  ///
  /// In a two player game, there are both player_a and player_b.
  /// Both players are "non-nil" througout the entire game.
  ///
  /// In a single player game, there is either player_a or player_b.
  /// The opponent player is "nil" thoughout the entire game.
  enum OneOf_OptionalPlayerA: Equatable {
    case playerA(SnakeDatasetPlayer)

  #if !swift(>=4.1)
    static func ==(lhs: SnakeDatasetStep.OneOf_OptionalPlayerA, rhs: SnakeDatasetStep.OneOf_OptionalPlayerA) -> Bool {
      switch (lhs, rhs) {
      case (.playerA(let l), .playerA(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalPlayerB: Equatable {
    case playerB(SnakeDatasetPlayer)

  #if !swift(>=4.1)
    static func ==(lhs: SnakeDatasetStep.OneOf_OptionalPlayerB, rhs: SnakeDatasetStep.OneOf_OptionalPlayerB) -> Bool {
      switch (lhs, rhs) {
      case (.playerB(let l), .playerB(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SnakeDatasetResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The game is taking place inside a level with this uuid and these properties.
  var level: SnakeDatasetLevel {
    get {return _storage._level ?? SnakeDatasetLevel()}
    set {_uniqueStorage()._level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return _storage._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {_uniqueStorage()._level = nil}

  /// Snapshot of what the grid looks like in the very first step.
  var firstStep: SnakeDatasetStep {
    get {return _storage._firstStep ?? SnakeDatasetStep()}
    set {_uniqueStorage()._firstStep = newValue}
  }
  /// Returns true if `firstStep` has been explicitly set.
  var hasFirstStep: Bool {return _storage._firstStep != nil}
  /// Clears the value of `firstStep`. Subsequent reads from it will return its default value.
  mutating func clearFirstStep() {_uniqueStorage()._firstStep = nil}

  /// Snapshot of what the grid looks like in the very last step.
  var lastStep: SnakeDatasetStep {
    get {return _storage._lastStep ?? SnakeDatasetStep()}
    set {_uniqueStorage()._lastStep = newValue}
  }
  /// Returns true if `lastStep` has been explicitly set.
  var hasLastStep: Bool {return _storage._lastStep != nil}
  /// Clears the value of `lastStep`. Subsequent reads from it will return its default value.
  mutating func clearLastStep() {_uniqueStorage()._lastStep = nil}

  /// Food positions throughout the game.
  /// Magic value is (0,0), this means that there is no food position.
  var foodPositions: [SnakeDatasetPosition] {
    get {return _storage._foodPositions}
    set {_uniqueStorage()._foodPositions = newValue}
  }

  /// Head positions of "player_a" througout the game.
  var playerAPositions: [SnakeDatasetPosition] {
    get {return _storage._playerAPositions}
    set {_uniqueStorage()._playerAPositions = newValue}
  }

  /// Head positions of "player_b" througout the game.
  var playerBPositions: [SnakeDatasetPosition] {
    get {return _storage._playerBPositions}
    set {_uniqueStorage()._playerBPositions = newValue}
  }

  /// When was this dataset generated.
  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SnakeDatasetCauseOfDeath: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OTHER"),
    1: .same(proto: "COLLISION_WITH_WALL"),
    2: .same(proto: "COLLISION_WITH_ITSELF"),
    3: .same(proto: "COLLISION_WITH_OPPONENT"),
    4: .same(proto: "STUCK_IN_LOOP"),
  ]
}

extension SnakeDatasetPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeDatasetPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.x)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.y)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeDatasetPosition, rhs: SnakeDatasetPosition) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SnakeDatasetPlayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeDatasetPlayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alive"),
    2: .standard(proto: "body_positions"),
    3: .same(proto: "uuid"),
    4: .standard(proto: "cause_of_death"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.alive)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.bodyPositions)
      case 3: try decoder.decodeSingularStringField(value: &self.uuid)
      case 4: try decoder.decodeSingularEnumField(value: &self.causeOfDeath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alive != false {
      try visitor.visitSingularBoolField(value: self.alive, fieldNumber: 1)
    }
    if !self.bodyPositions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyPositions, fieldNumber: 2)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 3)
    }
    if self.causeOfDeath != .other {
      try visitor.visitSingularEnumField(value: self.causeOfDeath, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeDatasetPlayer, rhs: SnakeDatasetPlayer) -> Bool {
    if lhs.alive != rhs.alive {return false}
    if lhs.bodyPositions != rhs.bodyPositions {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.causeOfDeath != rhs.causeOfDeath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SnakeDatasetLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeDatasetLevel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
    4: .standard(proto: "empty_positions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uuid)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.width)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.height)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.emptyPositions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 3)
    }
    if !self.emptyPositions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.emptyPositions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeDatasetLevel, rhs: SnakeDatasetLevel) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.emptyPositions != rhs.emptyPositions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SnakeDatasetIngame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeDatasetIngame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "step"),
  ]

  fileprivate class _StorageClass {
    var _level: SnakeDatasetLevel? = nil
    var _step: SnakeDatasetStep? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _level = source._level
      _step = source._step
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._level)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._step)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._level {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._step {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeDatasetIngame, rhs: SnakeDatasetIngame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._level != rhs_storage._level {return false}
        if _storage._step != rhs_storage._step {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SnakeDatasetStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeDatasetStep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "food_position"),
    2: .standard(proto: "player_a"),
    3: .standard(proto: "player_b"),
  ]

  fileprivate class _StorageClass {
    var _optionalFoodPosition: SnakeDatasetStep.OneOf_OptionalFoodPosition?
    var _optionalPlayerA: SnakeDatasetStep.OneOf_OptionalPlayerA?
    var _optionalPlayerB: SnakeDatasetStep.OneOf_OptionalPlayerB?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _optionalFoodPosition = source._optionalFoodPosition
      _optionalPlayerA = source._optionalPlayerA
      _optionalPlayerB = source._optionalPlayerB
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: SnakeDatasetPosition?
          if let current = _storage._optionalFoodPosition {
            try decoder.handleConflictingOneOf()
            if case .foodPosition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._optionalFoodPosition = .foodPosition(v)}
        case 2:
          var v: SnakeDatasetPlayer?
          if let current = _storage._optionalPlayerA {
            try decoder.handleConflictingOneOf()
            if case .playerA(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._optionalPlayerA = .playerA(v)}
        case 3:
          var v: SnakeDatasetPlayer?
          if let current = _storage._optionalPlayerB {
            try decoder.handleConflictingOneOf()
            if case .playerB(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._optionalPlayerB = .playerB(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .foodPosition(let v)? = _storage._optionalFoodPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if case .playerA(let v)? = _storage._optionalPlayerA {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if case .playerB(let v)? = _storage._optionalPlayerB {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeDatasetStep, rhs: SnakeDatasetStep) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._optionalFoodPosition != rhs_storage._optionalFoodPosition {return false}
        if _storage._optionalPlayerA != rhs_storage._optionalPlayerA {return false}
        if _storage._optionalPlayerB != rhs_storage._optionalPlayerB {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SnakeDatasetResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeDatasetResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .standard(proto: "first_step"),
    3: .standard(proto: "last_step"),
    4: .standard(proto: "food_positions"),
    5: .standard(proto: "player_a_positions"),
    6: .standard(proto: "player_b_positions"),
    7: .same(proto: "timestamp"),
  ]

  fileprivate class _StorageClass {
    var _level: SnakeDatasetLevel? = nil
    var _firstStep: SnakeDatasetStep? = nil
    var _lastStep: SnakeDatasetStep? = nil
    var _foodPositions: [SnakeDatasetPosition] = []
    var _playerAPositions: [SnakeDatasetPosition] = []
    var _playerBPositions: [SnakeDatasetPosition] = []
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _level = source._level
      _firstStep = source._firstStep
      _lastStep = source._lastStep
      _foodPositions = source._foodPositions
      _playerAPositions = source._playerAPositions
      _playerBPositions = source._playerBPositions
      _timestamp = source._timestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._level)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._firstStep)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastStep)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._foodPositions)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._playerAPositions)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._playerBPositions)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._level {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._firstStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._foodPositions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._foodPositions, fieldNumber: 4)
      }
      if !_storage._playerAPositions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._playerAPositions, fieldNumber: 5)
      }
      if !_storage._playerBPositions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._playerBPositions, fieldNumber: 6)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeDatasetResult, rhs: SnakeDatasetResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._level != rhs_storage._level {return false}
        if _storage._firstStep != rhs_storage._firstStep {return false}
        if _storage._lastStep != rhs_storage._lastStep {return false}
        if _storage._foodPositions != rhs_storage._foodPositions {return false}
        if _storage._playerAPositions != rhs_storage._playerAPositions {return false}
        if _storage._playerBPositions != rhs_storage._playerBPositions {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
