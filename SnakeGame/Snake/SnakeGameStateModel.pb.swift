// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SnakeGameStateModel.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Regenerate swift file
/// PROMPT> protoc --swift_out=. SnakeGameStateModel.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SnakeGameStateModelPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: UInt32 = 0

  var y: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SnakeGameStateModelPositionRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: SnakeGameStateModelPosition {
    get {return _storage._position ?? SnakeGameStateModelPosition()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return _storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {_uniqueStorage()._position = nil}

  var count: UInt32 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SnakeGameStateModelPlayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var headDirection: SnakeGameStateModelPlayer.HeadDirection = .up

  var bodyPositions: [SnakeGameStateModelPosition] = []

  var action: SnakeGameStateModelPlayer.Action = .die

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum HeadDirection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case up // = 0
    case left // = 1
    case right // = 2
    case down // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .up
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .up
      case 1: self = .left
      case 2: self = .right
      case 3: self = .down
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .up: return 0
      case .left: return 1
      case .right: return 2
      case .down: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum Action: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case die // = 0
    case moveForward // = 1
    case moveCw // = 2
    case moveCcw // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .die
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .die
      case 1: self = .moveForward
      case 2: self = .moveCw
      case 3: self = .moveCcw
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .die: return 0
      case .moveForward: return 1
      case .moveCw: return 2
      case .moveCcw: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension SnakeGameStateModelPlayer.HeadDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [SnakeGameStateModelPlayer.HeadDirection] = [
    .up,
    .left,
    .right,
    .down,
  ]
}

extension SnakeGameStateModelPlayer.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [SnakeGameStateModelPlayer.Action] = [
    .die,
    .moveForward,
    .moveCw,
    .moveCcw,
  ]
}

#endif  // swift(>=4.2)

struct SnakeGameStateModel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The level has a size: width * height.
  var levelWidth: UInt32 {
    get {return _storage._levelWidth}
    set {_uniqueStorage()._levelWidth = newValue}
  }

  var levelHeight: UInt32 {
    get {return _storage._levelHeight}
    set {_uniqueStorage()._levelHeight = newValue}
  }

  /// There is always the player A.
  var playerA: SnakeGameStateModelPlayer {
    get {return _storage._playerA ?? SnakeGameStateModelPlayer()}
    set {_uniqueStorage()._playerA = newValue}
  }
  /// Returns true if `playerA` has been explicitly set.
  var hasPlayerA: Bool {return _storage._playerA != nil}
  /// Clears the value of `playerA`. Subsequent reads from it will return its default value.
  mutating func clearPlayerA() {_uniqueStorage()._playerA = nil}

  /// There may be an opponent player B.
  var optionalPlayerB: OneOf_OptionalPlayerB? {
    get {return _storage._optionalPlayerB}
    set {_uniqueStorage()._optionalPlayerB = newValue}
  }

  var playerB: SnakeGameStateModelPlayer {
    get {
      if case .playerB(let v)? = _storage._optionalPlayerB {return v}
      return SnakeGameStateModelPlayer()
    }
    set {_uniqueStorage()._optionalPlayerB = .playerB(newValue)}
  }

  /// There may be food or there may be no food.
  var optionalFoodPosition: OneOf_OptionalFoodPosition? {
    get {return _storage._optionalFoodPosition}
    set {_uniqueStorage()._optionalFoodPosition = newValue}
  }

  var foodPosition: SnakeGameStateModelPosition {
    get {
      if case .foodPosition(let v)? = _storage._optionalFoodPosition {return v}
      return SnakeGameStateModelPosition()
    }
    set {_uniqueStorage()._optionalFoodPosition = .foodPosition(newValue)}
  }

  /// Obstacles such as walls, dead snakes.
  var obstaclesSingle: [SnakeGameStateModelPosition] {
    get {return _storage._obstaclesSingle}
    set {_uniqueStorage()._obstaclesSingle = newValue}
  }

  var obstaclesHorizontal: [SnakeGameStateModelPositionRange] {
    get {return _storage._obstaclesHorizontal}
    set {_uniqueStorage()._obstaclesHorizontal = newValue}
  }

  var obstaclesVertical: [SnakeGameStateModelPositionRange] {
    get {return _storage._obstaclesVertical}
    set {_uniqueStorage()._obstaclesVertical = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// There may be an opponent player B.
  enum OneOf_OptionalPlayerB: Equatable {
    case playerB(SnakeGameStateModelPlayer)

  #if !swift(>=4.1)
    static func ==(lhs: SnakeGameStateModel.OneOf_OptionalPlayerB, rhs: SnakeGameStateModel.OneOf_OptionalPlayerB) -> Bool {
      switch (lhs, rhs) {
      case (.playerB(let l), .playerB(let r)): return l == r
      }
    }
  #endif
  }

  /// There may be food or there may be no food.
  enum OneOf_OptionalFoodPosition: Equatable {
    case foodPosition(SnakeGameStateModelPosition)

  #if !swift(>=4.1)
    static func ==(lhs: SnakeGameStateModel.OneOf_OptionalFoodPosition, rhs: SnakeGameStateModel.OneOf_OptionalFoodPosition) -> Bool {
      switch (lhs, rhs) {
      case (.foodPosition(let l), .foodPosition(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SnakeGameStateModelPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeGameStateModelPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.x)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.y)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularUInt32Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularUInt32Field(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeGameStateModelPosition, rhs: SnakeGameStateModelPosition) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SnakeGameStateModelPositionRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeGameStateModelPositionRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "count"),
  ]

  fileprivate class _StorageClass {
    var _position: SnakeGameStateModelPosition? = nil
    var _count: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _position = source._position
      _count = source._count
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._position)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._count)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._count != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._count, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeGameStateModelPositionRange, rhs: SnakeGameStateModelPositionRange) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._position != rhs_storage._position {return false}
        if _storage._count != rhs_storage._count {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SnakeGameStateModelPlayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeGameStateModelPlayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "head_direction"),
    2: .standard(proto: "body_positions"),
    3: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.headDirection)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.bodyPositions)
      case 3: try decoder.decodeSingularEnumField(value: &self.action)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.headDirection != .up {
      try visitor.visitSingularEnumField(value: self.headDirection, fieldNumber: 1)
    }
    if !self.bodyPositions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyPositions, fieldNumber: 2)
    }
    if self.action != .die {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeGameStateModelPlayer, rhs: SnakeGameStateModelPlayer) -> Bool {
    if lhs.headDirection != rhs.headDirection {return false}
    if lhs.bodyPositions != rhs.bodyPositions {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SnakeGameStateModelPlayer.HeadDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UP"),
    1: .same(proto: "LEFT"),
    2: .same(proto: "RIGHT"),
    3: .same(proto: "DOWN"),
  ]
}

extension SnakeGameStateModelPlayer.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIE"),
    1: .same(proto: "MOVE_FORWARD"),
    2: .same(proto: "MOVE_CW"),
    3: .same(proto: "MOVE_CCW"),
  ]
}

extension SnakeGameStateModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SnakeGameStateModel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "level_width"),
    2: .standard(proto: "level_height"),
    3: .standard(proto: "player_a"),
    4: .standard(proto: "player_b"),
    5: .standard(proto: "food_position"),
    6: .standard(proto: "obstacles_single"),
    7: .standard(proto: "obstacles_horizontal"),
    8: .standard(proto: "obstacles_vertical"),
  ]

  fileprivate class _StorageClass {
    var _levelWidth: UInt32 = 0
    var _levelHeight: UInt32 = 0
    var _playerA: SnakeGameStateModelPlayer? = nil
    var _optionalPlayerB: SnakeGameStateModel.OneOf_OptionalPlayerB?
    var _optionalFoodPosition: SnakeGameStateModel.OneOf_OptionalFoodPosition?
    var _obstaclesSingle: [SnakeGameStateModelPosition] = []
    var _obstaclesHorizontal: [SnakeGameStateModelPositionRange] = []
    var _obstaclesVertical: [SnakeGameStateModelPositionRange] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _levelWidth = source._levelWidth
      _levelHeight = source._levelHeight
      _playerA = source._playerA
      _optionalPlayerB = source._optionalPlayerB
      _optionalFoodPosition = source._optionalFoodPosition
      _obstaclesSingle = source._obstaclesSingle
      _obstaclesHorizontal = source._obstaclesHorizontal
      _obstaclesVertical = source._obstaclesVertical
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._levelWidth)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._levelHeight)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._playerA)
        case 4:
          var v: SnakeGameStateModelPlayer?
          if let current = _storage._optionalPlayerB {
            try decoder.handleConflictingOneOf()
            if case .playerB(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._optionalPlayerB = .playerB(v)}
        case 5:
          var v: SnakeGameStateModelPosition?
          if let current = _storage._optionalFoodPosition {
            try decoder.handleConflictingOneOf()
            if case .foodPosition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._optionalFoodPosition = .foodPosition(v)}
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._obstaclesSingle)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._obstaclesHorizontal)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._obstaclesVertical)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._levelWidth != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._levelWidth, fieldNumber: 1)
      }
      if _storage._levelHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._levelHeight, fieldNumber: 2)
      }
      if let v = _storage._playerA {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if case .playerB(let v)? = _storage._optionalPlayerB {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if case .foodPosition(let v)? = _storage._optionalFoodPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._obstaclesSingle.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._obstaclesSingle, fieldNumber: 6)
      }
      if !_storage._obstaclesHorizontal.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._obstaclesHorizontal, fieldNumber: 7)
      }
      if !_storage._obstaclesVertical.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._obstaclesVertical, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SnakeGameStateModel, rhs: SnakeGameStateModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._levelWidth != rhs_storage._levelWidth {return false}
        if _storage._levelHeight != rhs_storage._levelHeight {return false}
        if _storage._playerA != rhs_storage._playerA {return false}
        if _storage._optionalPlayerB != rhs_storage._optionalPlayerB {return false}
        if _storage._optionalFoodPosition != rhs_storage._optionalFoodPosition {return false}
        if _storage._obstaclesSingle != rhs_storage._obstaclesSingle {return false}
        if _storage._obstaclesHorizontal != rhs_storage._obstaclesHorizontal {return false}
        if _storage._obstaclesVertical != rhs_storage._obstaclesVertical {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
